import { GameEvent, SimulationState, PlayerChoicePrompt, StaticGameDataCache, GameEventType } from '../types';
import { CommandFactory } from './commands/command.factory';
import { CommandResult, GameCommand } from './commands/types';

export interface ProcessingResult {
    finalState: SimulationState;
    results: CommandResult[];
    pendingChoices: PlayerChoicePrompt[];
    allEvents: GameEvent[];
    allVFX: any[]; // Replace with specific VFXRequest type later
    allAudio: any[]; // Replace with specific AudioEvent type later
    newQueue?: GameEvent[]; // For events generated by choice resolution
}

export class EventProcessor {
    private readonly commandFactory: CommandFactory;
    private readonly staticData: StaticGameDataCache;

    constructor(commandFactory: CommandFactory, staticData: StaticGameDataCache) {
        this.commandFactory = commandFactory;
        this.staticData = staticData;
    }

    public processEvents(
        events: readonly GameEvent[],
        initialState: SimulationState
    ): ProcessingResult {
        const sortedEvents = this.sortEventsByPriority(events);
        let currentState = initialState;
        const results: CommandResult[] = [];
        const pendingChoices: PlayerChoicePrompt[] = [];

        for (const event of sortedEvents) {
            const commands = this.commandFactory.createCommandsFromEvent(event, currentState, this.staticData);

            for (const command of commands) {
                const result = command.execute(currentState, { staticData: this.staticData });
                results.push(result);

                if (result.success) {
                    currentState = result.newState;
                } else {
                    // console.error(`Command failed: ${command.constructor.name}`, result.errors);
                }

                const choicePrompt = result.prompt;
                if (choicePrompt) {
                    pendingChoices.push(choicePrompt);
                    // The processing loop will be paused by the simulation slice, so we don't need to break here.
                }
            }
        }

        return {
            finalState: currentState,
            results,
            pendingChoices,
            allEvents: results.flatMap(r => r.events),
            allVFX: results.flatMap(r => r.visualEffects),
            allAudio: results.flatMap(r => r.audioEvents),
        };
    }
    
    public resolveChoice(prompt: PlayerChoicePrompt, selection: any): GameEvent[] {
        // This is a simplified resolution logic. A real engine might have more complex
        // mapping from choices to events.
        if (prompt.type === 'reaction' && selection) {
             // Example: if a reaction was to cast 'shield'
             if(selection === 'shield') {
                const castEvent: GameEvent = {
                    type: 'CAST_SPELL',
                    sourceId: prompt.sourceId,
                    spellId: 'shield',
                    upcastLevel: 1,
                    targets: { tokenIds: [prompt.sourceId] }
                };
                return [castEvent];
             }
        }
        return [];
    }

    private sortEventsByPriority(events: readonly GameEvent[]): readonly GameEvent[] {
        const priorityMap: Record<GameEventType, number> = {
            'APPLY_EFFECT': 1000,
            'DEAL_DAMAGE': 900,
            'HEAL_TARGET': 850,
            'DECLARE_ATTACK': 800,
            'CAST_SPELL': 750,
            'MOVE_TOKEN': 700,
            'USE_FEATURE': 600,
            'SPEND_RESOURCE': 500,
            'SPEND_ACTION': 400,
            'ATTEMPT_GRAPPLE_ESCAPE': 300,
            'DODGE_ACTION': 200,
            'HELP_ACTION': 150,
            'HIDE_ACTION': 150,
            'SEARCH_ACTION': 150,
            'DEAL_DAMAGE_TO_OBJECT': 100,
            'LOG_EVENT': 0,
        };

        return [...events].sort((a, b) => {
            const aPriority = priorityMap[a.type] ?? 0;
            const bPriority = priorityMap[b.type] ?? 0;
            return bPriority - aPriority;
        });
    }
}